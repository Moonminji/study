--------------------------------------------------------------------------------------------------------------------------------------------------------------

- 트랜잭션(Transaction) :  데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산
- 원자성 : 트랜잭션과 관련된 일은 모두 실행되던지 모두 실행되지 않도록 하던지를 보장하는 특성
- 일관성 : 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 후의 상태가 같아야 함
- 독립성 : 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우, 다른 트랜잭션의 연산 끼어들 수 없음
- 지속성 : 성공적으로 완료된 트랜잭션 결과는 시스템이 고장 나도 영구적으로 반영되어야 함

--------------------------------------------------------------------------------------------------------------------------------------------------------------

[Database Lock]: 데이터의 일관성을 보장하기 위한 방법
(시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 후의 상태가 같아야 한다.)

1)  Shared Lock (=Read Lock)
    원하는 데이터에 lock을 걸었지만, 다른 세션에서 읽을 수 있음
    공유 lock을 설정한 경우, 추가로 공유 lock을 설정할 수 있지만, 배타적 lock은 설정 X
    내가 보고 있는 데이터는 다른 사용자가 볼 수 있지만, 변경 불가능

2)  Exclusive Lock (=Write Lock)
    데이터 변경 시 사용
    해당 lock이 해제되기 전까지는 읽기, 쓰기가 불가능함
    SELECT ... FOR UPDATE나 UPDATE, DELETE 등의 수정 쿼리를 날릴 때 각 row에 걸리는 lock.
    다른 transaction이 수정하거나 삭제하고 있는 row는 읽기, 수정, 삭제가 전부 불가능하다.

3)  Dead Lock
    트랜잭션간의 교착상태.
    두개의 트랜잭션간에 각각의 트랜잭션이 가지고 있는 리소스의 lock을 획득할 때 발생.

    lock은 모든 transaction이 commit 되거나 rollback 될 때 함께 unlock 된다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------

[ Lock Level ]

1)  Row Level => 변경하려는 row에만 lock
2)  Page Level => 변경하려는 row가 담긴 데이터 페이지에 lock
3)  Table Level => 테이블과 인덱스에 모두 잠금을 설정
4)  Database Level => 데이터베이스를 복구하거나 스키마를 변경할 때 발생

--------------------------------------------------------------------------------------------------------------------------------------------------------------

MySQL에서 사용하는 잠금은 크게 MySQL 레벨과 스토리지 엔진 레벨로 나눌 수 있다.
MySQL 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치고,
스토리지 엔진 레벨의 잠금은 스토리지 간 상호 영향 안 미친다.

[MySQL 엔진 잠금]

1) Table lock
     어떤 세션에서 테이블 자원에 액세스하여 데이터를 읽거나 쓰기를 할 때, 다른 세션에서는 테이블 자원에 대한 액세스를 제한하는 lock.
    그 세션에서 lock을 해지하지 않으면, 다른 세션에서는 접근을 하지 못하게 된다.
    MyISAM이나 Memory DB에서 데이터를 변경하는 쿼리를 실행하면 자동으로 테이블 락이 획득된다. (쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료되면 자동으로 해제된다.)

    LOCK TABLES A READ | WRITE ;
    UNLOCK TABLES;

2) User lock
    사용자 레벨에서 락을 걸 수 있는 방법. 이 방법은 락의 이름과 그 락의 타임아웃을 정의해서 사용하는 방법이다

    GET_LOCK(str, timeout) ;
    RELEASE_LOCK(str) ;
    select GET_LOCK('user_define_lock', 10) => user_define_lock이라는 락을 10초동안 유지.

3) Global lock
    서버에 존재하는 모든 테이블에 잠금을 걸게 되며, MySQL에서 제공하는 락의 범위 중에 가장 크다.  => 모든 테이블 모든 레코드에 변경이 불가능하게 된다.

    FLUSH TABLES WITH READ LOCK;

4) Name lock
    테이블은 이름을 변경하거나 삭제될 때 테이블 레벨에서 묵시적으로 네임 락을 사용한다.

    RENAME TABLE A TO B;
    
